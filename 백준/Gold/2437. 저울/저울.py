"""
작은 것부터 하나씩 추가해가면서 지금까지의 수로 만들 수 있는 수 + 1을 만들어낼 수 있는지 확인
mn: 지금까지의 숫자로 만들 수 있는 가장 작은 수 (거의 1) => 초기값 0
mx: 지금까지의 숫자로 만들 수 있는 가장 큰 수 => 초기값 0
=> 1(mn)~mx 다 만들 수 있으므로 num을 추가 했을 때 mx+1 만들 수 있는지를 확인해야함
1(mn)~mx을 만들 수 있을 때, num을 넣어서 mx+1까지 만들 수 있다면 1~mx+num까지 다 만들 수 있으므로 mx+num이 mx가 됨

ex) 2
mn(0) + 2가지고는 mx + 1 = 1을 만들 수 없음 -> 1이 정답

ex) 1 1 2 3 6 7 30
초기 mn : 0, mx : 0 즉 0 ~ 0 만들 수 있음
1 => mn(0) + 1 : 1 즉, mx+1인 1 만들수 있음(0+1)
    => mx+num인 1까지 만들수 있음  mn : 1 mx : 1 (1 ~ 1 만들 수 있음)
1 => mn(1) + 1 : 2 즉, mx+1인 2 만들수 있음(1+1)
    => mx+num인 2까지 만들수 있음  mn : 1 mx : 2 (1 ~ 2 만들 수 있음)
2 => mn(1) + 2 : 3 즉, mx+1인 3 만들수 있음(1+2)
    => mx+num인 4까지 만들수 있음  mn : 1 mx : 3 (1 ~ 4 만들 수 있음)
3 => mn(1) + 3 : 4 즉, mx+1인 5 만들수 있음(2+3)
    => mx+num인 7까지 만들수 있음  mn : 1 mx : 7 (1 ~ 7 만들 수 있음)
6 => mn(1) + 6 : 7 즉, mx+1인 8 만들수 있음(2+6)
    => mx+num인 13까지 만들수 있음  mn : 1 mx : 13 (1 ~ 13 만들 수 있음)
7 => mn(1) + 7 : 8 즉, mx+1인 14 만들수 있음(7+7)
    => mx+num인 20까지 만들수 있음  mn : 1 mx : 20 (1 ~ 20 만들 수 있음)
30 => mn(1) + 30 : 31 mx+1인 21 만들수 없음! (가장 작은 1과 더해도 31이 되어버리므로)
    => mx+1이 만들 수 없는 가장 작은 양의 정수가 됨

"""

N = int(input())
lst = list(map(int, input().split()))
lst.sort()      # 오름차순 정렬

mn = 0
mx = 0
for num in lst:             # 작은거부터 하나씩 꺼내서
    if mn + num <= mx+1:    # mx+1을 만들 수 있는지 확인 mn+num이 mx+1보다 작거나 같다면, 1(mn)~mx 사이 적당한 값과 num을 더해 mx+1을 만들 수 있음
        mn = min(mn, num)   # (답이 1이 아니라면 1로 유지됨)
        mx = mx + num       # mx+1을 만들 수 있다면 1~mx+num의 모든 정수도 연속적으로 만들 수 있음
    else:
        print(mx + 1)       # mx+1보다 커서 mx+1만들수 없다면 mx+1이 정답이 됨
        break
else:               # (D) 끝까지 break 없던 경우 => sum(lst) + 1 (== mx + 1)가 정답이 됨
    print(mx + 1)
