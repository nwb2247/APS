"""
[조건]
크레인 수 N<=50
박수 수 M <= 10000
값 <=100_0000

1초에 박스 하나씩,
크레인은 무게제한 있음
모든 크레인은 동시에 옮길 수 있음

[목표]
최소시간 구하기

모든 박스를 옮길 수 없다면 ex) 모든 크레인 무게제한보다 큰 화물이 있는 경우
-1출력

[접근]
최단 시간에 처리하기 위해 평평하게 넣되, 될 수 있으면 무게제한이 가장 큰 크레인에 넣는다.

크레인 무게제한 오름차순 정렬
박스 내림차순 정렬
박스에서 큰거부터 하나씩 꺼내서 넣을 수 있는 크레인 찾기, 다음 크레과 대기열 길이가 같다면, 되도록 더 큰 크레인에 넣음
=> 대기열의 길이를 최대한 균일하게 유지하면서, 넣을 수 있는 가장 큰 크레인에 넣기
"""
def solve():
    N = int(input())
    climit = list(map(int, input().split()))    # 크레인 무게제한 리스트
    climit.sort()                               # 오름차순 정렬 (작은 것부터 넣기 시도)

    M = int(input())                            # 박스의 수
    boxes = list(map(int, input().split()))
    boxes.sort(reverse=True)                    # 박스는 내림차순 정렬 (큰 것부터 넣기 위해)

    loaded = [0]*N + [10001]                    # 크레인 별 대기열 (몇개를 쌓아두는지)

    for box in boxes:                           # 큰 박스부터 꺼내서
        for i in range(N):                      # 무게 제한 작은 크레인부터 커지는 순으로 확인해서 넣을 수 있는 가장 큰 크레인에 넣음
            if box > climit[i] or loaded[i+1] == loaded[i]:
                # [1] 박스 크기가 무게제한을 넘어가면 못 넣으므로 continue
                # [2] 다음 크레인의 대기열 크기가 현재 크레인과 같다면 더 큰 크레인에 우선적으로 넣어야하므로 continue
                continue
            else:
                loaded[i] += 1  # 넣을 수 있는 크레인에 도달했다면 +=1
                break
        else:   # 어디에도 넣을 수 없으면 break (즉, 가장 무게제한이 가장 큰 크레인에도 넣을 수 없다면)
            return -1

    return loaded[N-1]      # 항상 더 큰 크레인에 우선적으로 넣었으므로 마지막 크레인의 대기열이 가장 큼

print(solve())
