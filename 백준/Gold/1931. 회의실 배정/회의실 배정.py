"""
그리디
-> 규칙성 찾기 위해, 정렬을 많이 사용
-> 여러 방법을 생각하면서 반례를 생각해내고, 소거법으로 규칙을 찾기도 함

방법1. 가장 먼저 시작하는 회의     -> 가장 먼저 시작해서 가장 늦게 끝나는 경우
방법2. 가장 짧은 회의             -> 가장 짧은 회의가 두개의 선택가능한 회의에 걸쳐 있는 경우
방법3. 가장 빨리 끝나는 회의       -> 반례 x

선택 가능한 회의 중 가장 빨리 끝나는 회의 A를 고른다면,
그보다 늦게 끝나는 어떤 회의를 고르더라도
앞으로 A보다 절대 더 많은 수의 회의는 고를 수 없다 (적거나 같은 수의 회의만을 고를 수 있다.)

"""

N = int(input())
lst = [tuple(map(int, input().split())) for _ in range(N)]
# lst.sort(key=lambda x:(x[1])) # 끝나는 시간으로 정렬
lst.sort(key=lambda x:(x[1], x[0])) # 끝나는 시간으로 정렬 => 시작 시간으로 한번 더 정렬
"""
(D) 끝나는 시간으로 정렬, 그다음 시작 시간으로도 정렬해줘야 시작하자마자 끝나는 것도 제대로 넣어줄 수 있음
2
1 1
0 1
----
2 -> 정답
1 -> 오답 (key=lambda x:(x[1], x[0])) 가 이닌 (key=lambda x:(x[1])) 인경우..
"""

cnt = 0 # 개수
ce = 0  # 마지막 작업의 끝나는 시간
for ns, ne in lst:
    if ns >= ce:
        cnt += 1
        ce = ne

print(cnt)

